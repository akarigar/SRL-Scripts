program LumbridgeSmelter;
{$DEFINE SMART}
{$include akarigar/engine.simba}
{$ContinueCase ON}

const
  // Numeric
  P_BAR_XP = 0;
  P_BARS_MADE = 1;
  P_ITEM_NAME = 2;
  P_ITEM_SLOT = 3;
  P_ITEM_XP = 4;
  P_ITEMS_MADE = 5;

  // Booleans
  P_SMELT = 0;
  P_SMITH = 1;

  FAIL_MAX = 20;

var bankTask, smeltTask, smithTask: TTask;

procedure doAntiBan();
begin
  case Random(600) of
    1..10: sleepAndMoveMouse(randomRange(150, 1000));
    11..20:
    begin
      if random() > 0.75 then hoverSkill(SKILL_SMITHING)
      else hoverRandomSkill();
      continue;
    end;
    21..35:
    begin
      if random() > 0.5 then pickupMouse();
      smallRandomMouse(gaussRangeInt(400, 1200));
      wait(randomRange(500, 1000));
    end;
    36..150: if not minimap.isPlayerMoving() then mouseOffClient(OFF_CLIENT_RANDOM);
  end;
  if progressScreen.isOpen(500) then
    wait(gaussRangeInt(500, 3000))
  else
    wait(gaussRangeInt(0, 750));
end;

function smithItems(): TTaskStatus;
  var
    i, x, y, barsCount: integer;
    timer: TTimeMarker;
    water: TPointArray;
  begin
  repeat
    findColorsSpiralTolerance(x, y, water, 12955003, mainScreen.getBounds(), 6, colorSetting(2, 0.27, 0.74));
  until (length(water) >= 200) or (inc(i) >= FAIL_MAX);
  if i >= FAIL_MAX then exit(TTaskStatus.ERR);
  barsCount := tabBackpack.count();

  if not engine.useObject(
    6780019, // color
    11, // tolerance
    colorSetting(2, 0.83, 0.40), //colorSettings
    mainscreen.getBounds(), // bounds
    water.getMiddle(), // midPoint
    ['Smith', 'Anvil', 'mith', 'nvil'], // overText
    FAIL_MAX // tries
  ) then  exit(TTaskStatus.ERR);

  while (engine.randomlyWait(500, 1000)) and (inc(i) <= FAIL_MAX) and
        (not productionScreen.selectBox(13, ['bronze arrowheads', ' x15'])) do;
  if (i >= FAIL_MAX) then exit(TTaskStatus.ERR);
  i := 0;

  while (engine.randomlyWait()) and (not productionScreen.clickStart()) and (inc(i) < FAIL_MAX) do;
  if i >= FAIL_MAX then exit(TTaskStatus.ERR);
  i := 0;

  timer.start();
  while (progressScreen.isOpen(1500)) and (timer.getTime() < gaussRangeInt(110000, 130000)) do
    doAntiBan();
  if progressScreen.isOpen() then exit(TTaskStatus.ERR);

  // If we're making stackable items, then we get one item per bar.
  if findColor(x, y, 65535, tabBackpack.getBounds()) then
    inc(players[currentPlayer].integers[P_ITEMS_MADE], barsCount)
  else
    inc(players[currentPlayer].integers[P_ITEMS_MADE], tabBackpack.count());
  exit(TTaskStatus.DONE);
end;

function smeltBars(): TTaskStatus;
var i: integer = 0;
begin
  if not engine.useObject(
    1121716, // color
    13, // tolerance
    colorSetting(2, 0.04, 0.34), // colorSettings
    mainscreen.getBounds(), // bounds
    Point(-1, -1), // midPoint
    ['Smelt', 'Furnance', 'melt', 'urnance'], // overText
    FAIL_MAX // tries
  ) then exit(TTaskStatus.ERR);


  while (engine.randomlyWait()) and (not productionScreen.clickStart()) and (inc(i) < FAIL_MAX) do;
  if (i >= FAIL_MAX) or (not tabBackpack.waitSlotPixelChange(tabBackpack.count(), gaussRangeInt(110000, 130000))) then
    exit(TTaskStatus.ERR);

  inc(players[currentPlayer].integers[P_BARS_MADE], tabBackpack.count());
  exit(TTaskStatus.DONE);
end;

function loadPreset(): TTaskStatus;
var i: integer = 0;
begin
  while (engine.randomlyWait()) and (not bankscreen.open(BANK_CHEST_LUMBRIDGE)) and (inc(i) < FAIL_MAX) do;
  if i >= FAIL_MAX then exit(TTaskStatus.ERR);
  i := 0;

  while (engine.randomlyWait()) and (not bankScreen.clickButton(BANK_BUTTON_PRESET_1)) and (inc(i) < FAIL_MAX) do;
  if (i >= FAIL_MAX) or (not engine.randomlyWait()) or (tabBackpack.isEmpty()) then exit(TTaskStatus.ERR);
  exit(TTaskStatus.DONE);
end;

function loadTasks(): TTaskList;
var tasks: TTaskList;
begin
  with players[currentPlayer] do
  begin
    tasks.append(bankTask);
    if booleans[P_SMELT] then
      tasks.append(smeltTask);
    if booleans[P_SMITH] then
      tasks.append(smithTask);
  end;
  exit(tasks);
end;

procedure declarePlayers();
var i, index: integer;
begin
  for i := 0 to high(players) do
    with playerForm.players[i] do
    begin
      index := -1;
      players[i].extendeds[P_BAR_XP] := strToFloat(settings[inc(index)]);
      players[i].extendeds[P_ITEM_XP] := strToFloat(settings[inc(index)]);
      players[i].integers[P_ITEM_SLOT] := strToInt(settings[inc(index)]);

      players[i].strings[P_ITEM_NAME] := settings[inc(index)];

      index := high(playerForm.editBoxLabels);
      players[i].booleans[P_SMELT] := strToBool(settings[inc(index)]);
      players[i].booleans[P_SMITH] := strToBool(settings[inc(index)]);
      if not (players[i].booleans[P_SMELT] or players[i].booleans[P_SMITH]) then
        terminateScript();
    end;
end;

procedure initPlayerForm();
begin
  with playerForm do
  begin
    name := 'Lumbridge Smelter & Smither';

    // Setup edit boxes
    editBoxLabels := ['XP per bar', 'XP per item', 'Item slot', 'Item name'];
    editBoxDefaults := ['6.2', '12.5', '13', 'arrowheads'];
    editBoxHints := [
      'The XP gained by smelting one bar.',
      'The XP gained by smithing one item.',
      'The slot number in the production screen for the item you want to make.',
      'The name of the item you want to make. Omit the type (bronze, rune).'
    ];

    // Setup check boxes
    checkBoxLabels := ['Smelt?', 'Smith?'];
    checkBoxDefaults := ['True', 'True'];
    checkBoxHints := [
      'Should I smelt ore into bars?',
      'Should I smith (after smelting, if applicable) bars into items?'
    ];
  end;
end;

procedure showProgress(timeRan: integer);
var smeltCount, smeltXp, smithCount, smithXp, totalXp: integer = 0;
begin
  with players[currentPlayer] do
  begin
    writeLn('================================================================');
    writeLn('Lumbridge Smelter & Smither Progress Report');
    writeLn('Player[', currentPlayer, ']: ', nickname);
    writeLn('Played for ', msToTime(timeRan, TIME_FORMAL));
    writeLn('Breaked for ', msToTime(integers[P_TIME_BREAKED], TIME_FORMAL),' (',
            integers[P_BREAK_COUNT], ' breaks)');

    if booleans[P_SMELT] then
    begin
      smeltCount := integers[P_BARS_MADE];
      smeltXp := round(smeltCount * extendeds[P_BAR_XP]);
      totalXp += smeltXp;
      writeLn(formatProgressLine('Bars smelted: ', smeltCount, timeRan));
      writeLn(formatProgressLine('XP from smelting: ', smeltXp, timeRan));
    end;

    if booleans[P_SMITH] then
    begin
      smithCount := integers[P_ITEMS_MADE];
      smithXp := round(smithCount * extendeds[P_ITEM_XP]);
      totalXp += smithXp;
      writeLn(formatProgressLine('Items smithed: ', smithCount, timeRan));
      writeLn(formatProgressLine('XP from smithing: ', smithXp, timeRan));
    end;

    writeLn(formatProgressLine('Total XP: ', totalXp, timeRan));
    writeLn('================================================================');
  end;
end;

begin
  clearDebug();

  bankTask := TTask(['Bank', [Point(102, 98)], loadPreset]);
  smeltTask := TTask(['Smelt', [Point(150, 110)], smeltBars]);
  smithTask := TTask(['Smith', [Point(162, 114)], smithItems]);

  initPlayerForm();
  engine
    .loadArea('AKARIGAR_LUMBRIDGE')
    .setAntiBan(doAntiBan)
    .setDeclarePlayers(declarePlayers)
    .setProgressPrinter(showProgress)
    .setTaskLoader(loadTasks)
    .run();
end.
