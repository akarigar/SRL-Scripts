{$include_once srl-6/srl.simba}
{$include_once srl-6/lib/misc/srlplayerform.simba}

{$include_once engine/core/activity.simba}
{$include_once engine/core/activitymanager.simba}
{$include_once engine/core/playermanager.simba}
{$include_once engine/core/task.simba}
{$include_once engine/util/bank.simba}
{$f-}

{ This is just a very initial design, it is missing some key things
  (like dependency, biometrics, etc). Much of the stuff here is still not
  finalized. I'm going to be adding things as needed. I'll be moving things out
  of this and making their own files as they become big.
}

type
  PEngine = ^TEngine;

  TEngine = record
    antiBan: procedure();
    declarePlayers: procedure(engine: PEngine);

    __activity: PActivity;
    __activityManager: TActivityManager;
  end;

var engine: TEngine = [nil, nil, nil, [nil, nil]];

// Setters =====================================================================

function TEngine.setActivityCreator(f: function(s: string): PActivity): TEngine;
begin
  self.__activityManager.setActivityCreator(f);
  exit(self);
end;

function TEngine.setAntiBan(antiBan: procedure()): TEngine;
begin
  self.antiBan := antiBan;
  exit(self);
end;

function TEngine.setDeclarePlayers(declarePlayers: procedure(engine: PEngine)): TEngine;
begin
  self.declarePlayers := declarePlayers;
  exit(self);
end;

// End Setters =================================================================

function TEngine.loadArea(mapName: string): TEngine;
begin
  playerManager.loadArea(mapName);
  exit(self);
end;

procedure TEngine.printProgress(timeRan: integer);
var
  i: integer;
  totalXp: extended = 0;
  task: PTask;
begin
  with players[currentPlayer] do
  begin
    writeLn('================================================================');
    if length(playerForm.name) = 0 then
      writeLn('Progress Report')
    else
      writeLn(playerForm.name, ' Progress Report');
    writeLn('Player[', currentPlayer, ']: ', nickname);
    writeLn('Played for ', msToTime(timeRan, TIME_FORMAL));
    writeLn('Breaked for ', msToTime(integers[P_TIME_BREAKED], TIME_FORMAL),' (',
            integers[P_BREAK_COUNT], ' breaks)');

    writeLn('Activity ', self.__activity^.name, ' looped ', integers[P_LOOP_COUNT], ' times');
    for i := 0 to high(self.__activity^.tasks) do
    begin
      task := self.__activity^.tasks[i];
      if (task^.xpPerItem <= 0) or (task^.reportProgress = nil) then continue;
      totalXp += task^.reportProgress(timeRan);
    end;

    writeLn(formatProgressLine('Total XP: %d (%d/hr)', round(totalXp), timeRan));
    writeLn('================================================================');
  end;
end;

procedure TEngine.__declarePlayers();
var
  i: integer;
begin
  players.setup(playerForm.players);

  if self.declarePlayers <> nil then
    self.declarePlayers(@self);

  for i := 0 to high(players) do
    with playerForm.players[i] do
    begin
      players[i].world := strToInt(settings[high(playerForm.editBoxLabels) - 2]);
      players[i].integers[P_PLAY_TIME] := strToInt(settings[high(playerForm.editBoxLabels) - 1]) * 60000;
      players[i].integers[P_BREAK_LENGTH] := strToInt(settings[high(playerForm.editBoxLabels)]) * 60000;
      players[i].booleans[P_TAKE_BREAKS] := strToBool(settings[high(settings)]);

      // Set up the time for the next break, if we are taking breaks.
      if players[i].booleans[P_TAKE_BREAKS] then
        players[i].integers[P_NEXT_BREAK] := getGaussRangePercentage(players[i].integers[P_PLAY_TIME], 0.2);
    end;
end;

procedure TEngine.__destroy();
begin
  writeLn('Freeing engine resources');
  self.__activity := nil;
  self.__activityManager.destroy();
end;

function TEngine.__execute(task: PTask): boolean;
var
  status: TTaskStatus;
begin
  wait(gaussRangeInt(0, 1200));
  writeLn('Starting task "', task^.name, '"');
  if not playerManager.walkPath(task^.pathToTask) then exit(false);
  status := task^.run();
  writeLn('Task "', task^.name, '" finished with status ', status);
  exit(status > TTaskStatus.ERR);
end;

function TEngine.__execute(tasks: TTaskList): boolean; overload;
var currentTask: integer;
begin
  for currentTask := 0 to high(tasks) do
    if not self.__execute(tasks[currentTask]) then exit(false);
  exit(true);
end;

procedure TEngine.__initForm();
begin
  with playerForm do
  begin
    editBoxLabels.combine(['World', 'Take a break around (mins)', 'Duration of break (mins)']);
    editBoxDefaults.combine(['-1', '60', '5']);
    editBoxHints.combine([
      'What world to use? (-1 means use current, 0 means use random)',
      'Around how long to run before taking a break?',
      'Around how long should the break be?'
    ]);

    checkBoxLabels.combine(['Take Breaks']);
    checkBoxDefaults.combine(['True']);
    checkBoxHints.combine(['Should I take breaks?']);
  end;
end;

procedure TEngine.__runLoop();
var timer: TTimeMarker;
begin
  print('TEngine.__runLoop()');
  SRL_Events[EVENT_ANTIBAN] := self.antiBan;
  while players.getActive() > 0 do
  begin
    timer.start();
    if not isLoggedIn() then players[currentPlayer].login();
    wait(Random(500, 1500));
    closeAdWindow();
    closePollWindow();
    exitTreasure();
    mainscreen.setAngle(MS_ANGLE_HIGH);

    // Setup activity if needed & only start loop if everything is fine.
    self.__activity := self.__activityManager.next();

    with players[currentPlayer] do
    begin
      while playerManager.isActive() and (not self.__activity^.isDone()) and
          ((not booleans[P_TAKE_BREAKS]) or (timer.getTime() <= integers[P_NEXT_BREAK])) do
      begin
        isActive := self.__execute(self.__activity^.tasks);
        inc(integers[P_LOOP_COUNT]);

        self.printProgress(integers[P_TIME_RAN] + timer.getTime());
      end;
    end;
    writeLn('isDone? ', self.__activity^.isDone());
    inc(players[currentPlayer].integers[P_TIME_RAN], timer.getTime());

    if self.__activity^.isDone() then
      self.__activity := self.__activityManager.next()

    if players[currentPlayer].isActive then
      if timer.getTime() > players[currentPlayer].integers[P_NEXT_BREAK] then
        playerManager.takeBreak()
    else if players.getActive() > 0 then
      players.randomNext(false);

    if isLoggedIn() then
      players[currentPlayer].logout();
    timer.reset();
  end;
end;

function TEngine.run(): boolean;
begin
  self.__initForm();
  runPlayerForm();
  if not playerForm.isScriptReady then exit(false);

  self.__declarePlayers();
  if not setupSRL() then exit(false);

{$IFDEF SMART}
  smartEnableDrawing := true;
{$ENDIF}
  addOnTerminate('destroyEngine');
  self.__runLoop();
  exit(true);
end;

procedure destroyEngine();
begin
  engine.__destroy();
end;
