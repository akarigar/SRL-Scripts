{$f-}

{
  In the future, the idea is to be able to load most of the task's data from
  some local or hosted db. So, things like relevant colors, xp tables etc can
  be created based on location or the name of the item being gained.
}

const FAIL_MAX = 20;

type TTaskStatus = (
  ERR,
  DONE
);

type TTask = record
  name: string;
  location, tries, flag, itemsGained: integer;
  recipe: TRecipe;
  pathToObject, objectLocations: TPointArray;
  objectSettings: PObjectSettings;
  __run: function(): TTaskStatus of object;
  reportProgress: function(timeRan: integer): extended of object;
end;

type PTask = ^TTask;

procedure TTask.free();
var i: integer;
begin
  for i := 0 to high(self.recipe.itemsOut) do
    if dtmExists(self.recipe.itemsOut[i].dtm) then
      freeDtm(self.recipe.itemsOut[i].dtm);

  if self.objectSettings = nil then exit;
  self.objectSettings^.free();
  dispose(self.objectSettings);
end;

procedure TTask.init(name, data: string; f: function(): TTaskStatus of object);
var i: integer;
begin
  self.name := name;
  self.location := strToInt(between('<loc>', '</loc>', data));
  self.tries := FAIL_MAX;
  self.flag := strToInt(between('<flag>', '</flag>', data));
  self.pathToObject := strToTPA(between('<pto>', '</pto>', data));
  self.objectLocations := strToTPA(between('<ol>', '</ol>', data));
  self.objectSettings := xmlToObjectSettings(between('<s>', '</s>', data));
  self.recipe.fromXml(between('<recipe>', '</recipe>', data));
  self.__run := f;
  self.reportProgress := self.__reportTaskProgress;

  // Make the DTMs
  for i := 0 to high(self.recipe.itemsOut) do
    self.recipe.itemsOut[i].dtm := dtmFromString(self.recipe.itemsOut[i].dtmString);
end;

function TTask.run(): TTaskStatus;
var count, i, j: integer;
begin
  result := self.__run();

  // Update resources based on what has been produced
  for i := 0 to high(self.recipe.itemsOut) do
  begin
    count := tabBackpack.countDtm(self.recipe.itemsOut[i].dtm);
    inc(self.recipe.itemsOut[i].count, count);
    resourceManager.updateResource(self.recipe.itemsOut[i].name, count);
    for j := 0 to high(self.recipe.itemsIn) do
      resourceManager.updateResource(self.recipe.itemsIn[i].name, -count);
  end;
end;

function TTask.__reportTaskProgress(timeRan: integer): extended;
var
  i: integer;
  totalXp, xp: extended = 0;
begin
  for i := 0 to high(self.recipe.itemsOut) do
  begin
    xp := self.recipe.itemsOut[i].count * self.recipe.itemsOut[i].xp;
    totalXp += xp;
    writeLn(formatProgressLine(
      self.recipe.itemsOut[i].name,
      self.recipe.itemsOut[i].count,
      timeRan
    ));
    writeLn(formatProgressLine(
      self.recipe.itemsOut[i].name + ' XP',
      round(xp),
      timeRan
    ));
  end;
  exit(totalXp);
end;

type TTaskList = array of PTask;

procedure TTaskList.append(task: PTask);
begin
  setLength(self, length(self) + 1);
  self[high(self)] := task;
end;

procedure TTaskList.clear();
var i: integer;
begin
  for i := 0 to high(self) do
  begin
    self[i]^.free();
    dispose(self[i]);
  end;
  setLength(self, 0);
end;

function TTaskList.size(): integer;
begin
  exit(length(self));
end;

{$f+}
